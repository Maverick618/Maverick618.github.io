# 系统调用
> LiteOS-a v3.1
<!-- 
系统调用
 -->
## 系统调用文件结构
 - `syscall/syscall_lookup.h`：系统调用表；
 - `syscall/los_syscall.h`：系统调用函数声明；
 - `syscall/los_syscall.c`：系统调用初始化函数与系统调用处理函数实现；
 - `syscall`目录下的其他文件应该是对所有系统调用函数的实现。

!!! note ""

    每个系统调用都由宏函数SYSCALL_HAND_DEF定义，其参数为系统调用号、系统调用函数名、返回值类型、参数个数。
    ```C++
    SYSCALL_HAND_DEF(__NR_exit, SysThreadExit, void, ARG_NUM_1)
    SYSCALL_HAND_DEF(__NR_fork, SysFork, int, ARG_NUM_0)
    SYSCALL_HAND_DEF(__NR_vfork, SysVfork, int, ARG_NUM_0)
    SYSCALL_HAND_DEF(__NR_getpid, SysGetPID, unsigned int, ARG_NUM_0)
    SYSCALL_HAND_DEF(__NR_pause, SysPause, int, ARG_NUM_0)

    SYSCALL_HAND_DEF(__NR_kill, SysKill, int, ARG_NUM_2)
    ```

## 系统调用初始化函数
```C++
void OsSyscallHandleInit(void)
{
#define SYSCALL_HAND_DEF(id, fun, rType, nArg)                                             \
    if ((id) < SYS_CALL_NUM) {                                                             \
        g_syscallHandle[(id)] = (UINTPTR)(fun);                                            \
        g_syscallNArgs[(id) / NARG_PER_BYTE] |= ((id) & 1) ? (nArg) << NARG_BITS : (nArg); \
    }                                                                                      \

    #include "syscall_lookup.h"
#undef SYSCALL_HAND_DEF
}
```

系统调用初始化函数`OsSyscallHandleInit`会遍历系统调用表，将系统调用函数指针与参数个数存入全局变量`g_syscallHandle`与`g_syscallNArgs`中。

系统调用的数目由`#define SYS_CALL_NUM    (__NR_syscallend + 1)`决定，但是`__NR_syscallend`的定义我没有找到。

系统调用的参数数量一般不会特别大，因此记录参数数量的全局数组`g_syscallNArgs`的类型是`UINT8`，每个系统调用的参数数量用4bit表示。


## 系统调用处理函数
```C++
/* The SYSCALL ID is in R7 on entry.  Parameters follow in R0..R6 */
VOID OsArmA32SyscallHandle(TaskContext *regs)
{
    UINT32 ret;
    UINT8 nArgs;
    UINTPTR handle;
    UINT32 cmd = regs->reserved2;

    if (cmd >= SYS_CALL_NUM) {
        PRINT_ERR("Syscall ID: error %d !!!\n", cmd);
        return;
    }

    handle = g_syscallHandle[cmd];
    nArgs = g_syscallNArgs[cmd / NARG_PER_BYTE]; /* 4bit per nargs */
    nArgs = (cmd & 1) ? (nArgs >> NARG_BITS) : (nArgs & NARG_MASK);
    if ((handle == 0) || (nArgs > ARG_NUM_7)) {
        PRINT_ERR("Unsupported syscall ID: %d nArgs: %d\n", cmd, nArgs);
        regs->R0 = -ENOSYS;
        return;
    }

    OsSigIntLock();
    switch (nArgs) {
        case ARG_NUM_0:
        case ARG_NUM_1:
            ret = (*(SyscallFun1)handle)(regs->R0);
            break;
        case ARG_NUM_2:
        case ARG_NUM_3:
            ret = (*(SyscallFun3)handle)(regs->R0, regs->R1, regs->R2);
            break;
        case ARG_NUM_4:
        case ARG_NUM_5:
            ret = (*(SyscallFun5)handle)(regs->R0, regs->R1, regs->R2, regs->R3, regs->R4);
            break;
        default:
            ret = (*(SyscallFun7)handle)(regs->R0, regs->R1, regs->R2, regs->R3, regs->R4, regs->R5, regs->R6);
    }

    regs->R0 = ret;
    OsSigIntUnlock();

    return;
}
```
`OsArmA32SyscallHandle`函数接受一个名为`regs`的`TaskContext`类型的参数，这个参数包含了系统调用发生时的寄存器状态。

变量定义：`ret`用于存储系统调用函数的返回值，`nArgs`是系统调用的参数数量，`handle`是系统调用处理函数的地址，`cmd`是从`regs`中获取的系统调用ID。

系统调用ID检查:`if`语句检查`cmd`是否大于或等于`SYS_CALL_NUM`，如果是，那么打印错误信息并返回，因为这意味着系统调用ID无效。

系统调用函数地址和参数数量获取：从`g_syscallHandle`数组中获取与`cmd`对应的系统调用处理函数的地址，并从`g_syscallNArgs`数组中获取该系统调用需要的参数数量。注意，`g_syscallNArgs`数组中的每个元素存储了两个系统调用的参数数量，所以需要通过位操作来获取正确的参数数量。

系统调用处理函数地址检查：`if`语句检查获取的系统调用处理函数地址是否为0，或者参数数量是否大于`ARG_NUM_7`。如果是，那么打印错误信息，设置`regs->R0`为`-ENOSYS`，然后返回。`-ENOSYS`定义为40。`ARG_NUM_7`的定义我还没找到，可能就是7。

函数调用：函数锁定信号中断，然后根据参数数量调用相应的系统调用处理函数。注意，这里使用了函数指针，函数指针的类型（`SyscallFun1`、`SyscallFun3`、`SyscallFun5`或`SyscallFun7`）取决于参数数量。

最后，函数将系统调用处理函数的返回值存储在`regs->R0`中，解锁信号中断，然后返回。`R0`的类型为`UINT32`。

## 部分系统调用函数

<!-- 一下内容除代码和结构外，由AI生成，需要校对修改 -->

### SysKill
```C++
int SysKill(pid_t pid, int sig)
{
    return OsKillLock(pid, sig);
}
```

`SysKill`函数是一个简单的系统调用函数，它接受两个参数：`pid`和`sig`。`pid`是要发送信号的进程的ID，`sig`是要发送的信号的编号。
`SysKill`函数调用了`OsKillLock`函数，这个函数会向指定的进程发送一个信号。

```C++
int OsKillLock(pid_t pid, int sig)
{
    int ret;
    unsigned int intSave;

    SCHEDULER_LOCK(intSave);
    ret = OsKill(pid, sig, OS_USER_KILL_PERMISSION);
    SCHEDULER_UNLOCK(intSave);
    return ret;
}
```

`OsKillLock`函数会先锁定调度器，然后调用`OsKill`函数，最后解锁调度器并返回`OsKill`函数的返回值。

```C++
int OsKill(pid_t pid, int sig, int permission)
{
    siginfo_t info;
    int ret;

    /* Make sure that the para is valid */
    if (!GOOD_SIGNO(sig)) {
        return -EINVAL;
    }

    /* Create the siginfo structure */
    info.si_signo = sig;    //信号编号
    info.si_code = SI_USER; //来自用户进程信号
    info.si_value.sival_ptr = NULL;

    if (pid > 0) {
        /* Send the signal to the specify process */
        ret = OsDispatch(pid, &info, permission);   //发送信号
    } else if (pid == -1) {
        /* Send SIG to all processes */
        ret = OsSendSignalToAllProcess(&info, permission);  
    } else {
        /* Send SIG to all processes in process group PGRP.
           If PGRP is zero, send SIG to all processes in
           the current process's process group. */
        ret = OsSendSignalToProcessGroup(pid, &info, permission);
    }
    return ret;
}
```
`OsKill`函数会检查信号编号是否有效，并创建一个`siginfo_t`结构体，填充信号编号、信号来源和信号值。接着根据`pid`的值来决定向哪个进程发送信号，然后调用相应的函数来发送信号。

### SysFutex

```C++
int SysFutex(const unsigned int *uAddr, unsigned int flags, int val,
             unsigned int absTime, const unsigned int *newUserAddr)
{
    if ((flags & FUTEX_MASK) == FUTEX_REQUEUE) {
        return -OsFutexRequeue(uAddr, flags, val, absTime, newUserAddr);
    }

    if ((flags & FUTEX_MASK) == FUTEX_WAKE) {
        return -OsFutexWake(uAddr, flags, val);
    }

    return -OsFutexWait(uAddr, flags, val, absTime);
}
```

**Futex模块接口**

| 功能分类       | 接口**名称**   | 描述                                  |
| -------------- | -------------- | ------------------------------------- |
| 设置线程等待   | OsFutexWait    | 向Futex表中插入代表被阻塞的线程的node |
| 唤醒被阻塞线程 | OsFutexWake    | 唤醒一个被指定锁阻塞的线程            |
| 调整锁的地址   | OsFutexRequeue | 调整指定锁在Futex表中的位置           |

OsFutexRequeue就是把锁迁移到一个新的用户态地址上，在hash桶中删除旧node，插入新node

### SysPause 

```C++
int SysPause(void)
{
    return OsPause();
}
```
`SysPause`函数是调用了`OsPause`函数，用于暂停任务。
```C++
int OsPause(void)
{
    LosTaskCB *spcb = NULL;
    sigset_t oldSigprocmask;

    spcb = OsCurrTaskGet();
    oldSigprocmask = spcb->sig.sigprocmask;
    return OsSigSuspend(&oldSigprocmask);
}
```
`OsPause`函数获取当前任务的控制块，然后获取当前任务的信号掩码，最后调用`OsSigSuspend`函数。

### SysSigSuspend

```C++
int SysSigSuspend(sigset_t_l *setl)
{
    sigset_t set;
    int retVal;

    retVal = LOS_ArchCopyFromUser(&set, &(setl->sig[0]), sizeof(sigset_t));
    if (retVal != 0) {
        return -EFAULT;
    }

    return OsSigSuspend(&set);
}
```
`SysSigSuspend`函数接受一个`sigset_t_l`类型的参数，这个参数是一个结构体，包含一个`sigset_t`类型的数组。`SysSigSuspend`函数会将这个数组拷贝到一个`sigset_t`类型的变量中，然后调用`OsSigSuspend`函数。
`sigset_t_l`结构体的定义如下：
```C++
#define MAX_SIG_ARRAY_IN_MUSL 128

typedef struct {
    unsigned long sig[MAX_SIG_ARRAY_IN_MUSL / sizeof(unsigned long)];
} sigset_t_l;
```
`sigset_t`类型的定义没找到。

```C++
///用参数set代替进程的原有掩码，并暂停进程执行，直到收到信号再恢复原有掩码并继续执行进程。
///参数set是要屏蔽的信号
int OsSigSuspend(const sigset_t *set)
{
    unsigned int intSave;
    LosTaskCB *rtcb = NULL;
    sigset_t setSuspend;
    int ret;

    if (set == NULL) {
        return -EINVAL;
    }
    SCHEDULER_LOCK(intSave);
    rtcb = OsCurrTaskGet();

    /* Wait signal calc */
    setSuspend = FULL_SIGNAL_SET & (~(*set));

    /* If pending mask not in sigmask, need set sigflag */
    OsSigMaskSwitch(rtcb, *set);

    if (rtcb->sig.sigFlag > 0) {
        SCHEDULER_UNLOCK(intSave);

        /*
         * If rtcb->sig.sigFlag > 0, it means that some signal have been
         * received, and we need to do schedule to handle the signal directly.
         */
        LOS_Schedule();
        return -EINTR;
    } else {
        ret = OsSigTimedWaitNoLock(&setSuspend, NULL, LOS_WAIT_FOREVER);
        if (ret < 0) {
            PRINT_ERR("FUNC %s LINE = %d, ret = %x\n", __FUNCTION__, __LINE__, ret);
        }
    }

    SCHEDULER_UNLOCK(intSave);
    return -EINTR;
}
```
`OsSigSuspend`函数定义了一些变量，包括`intSave`、`rtcb`、`setSuspend`和`ret`。然后检查参数`set`是否为`NULL`，如果是，那么返回`-EINVAL`。

锁定调度器，并获取当前任务的任务控制块。然后，它计算出要等待的信号集`setSuspend`，这个信号集是全信号集与`set`的补集的交集。

如果挂起的掩码不在`sigmask`中，需要设置`sigflag`。使用`OsSigMaskSwitch`函数，将当前任务的信号掩码切换为`set`。

如果当前任务的信号标志`sigFlag`大于0，意味着已经接收到了一些信号，需要立即处理这些信号那么解锁调度器，并调用`LOS_Schedule`函数进行调度，然后返回`-EINTR`；否则，函数调用`OsSigTimedWaitNoLock`函数，等待`setSuspend`中的信号，等待时间为无限。如果`OsSigTimedWaitNoLock`函数返回值小于0，那么打印错误信息。

最后，函数解锁调度器，并返回`-EINTR`。